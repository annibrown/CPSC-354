\documentclass{article}

\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{graphicx}
\usepackage{float}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{quiver}
\usepackage{array}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}
\usepackage[utf8]{inputenc}                                                    
\usepackage[T1]{fontenc}                                                       

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\newtheoremstyle{theorem}
  {\topsep}   % ABOVESPACE
  {\topsep}   % BELOWSPACE
  {\itshape\/}  % BODYFONT
  {0pt}       % INDENT (empty value is the same as 0pt)
  {\bfseries} % HEADFONT
  {.}         % HEADPUNCT
  {5pt plus 1pt minus 1pt} % HEADSPACE
  {}          % CUSTOM-HEAD-SPEC
\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{CPSC-354 Report}
\author{Annika Brown  \\ Chapman University}

\date{\today} 

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents

\section{Introduction}\label{intro}

\section{Week by Week}\label{homework}

\subsection{Week 1}

\subsubsection{MU Puzzle}

It is impossible to solve the MU puzzle. The only way to change the amount of I’s is to double them with rule 2, or subtract 3 with rule 3. In order to get rid of all the I’s you would have to have them in groups of 3. A power of x is divisible by 3 only if x is a multiple of 3, because the prime factorization of a number must include the prime number 3 for the number to be divisible by 3. So, you would have to get an original group divisible by 3, which is impossible.

\subsection{Week 2}

\subsubsection{Rewriting}

1. \quad A=\{\}\\
Empty ARS\\
Terminating: Yes\\
Confluent: Yes\\
Has Unique Normal Forms: Yes

2. \quad A=\{a\}\quad and \quad {R}=\{\}

\begin{tikzcd}
	a
\end{tikzcd}\\
Terminating: Yes\\
Confluent: Yes\\
Has Unique Normal Forms: Yes

3. \quad A=\{a\}\quad and \quad {R}=\{(a,a)\}

\begin{tikzcd}
	a
	\arrow[from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
\end{tikzcd}\\
Terminating: No\\
Confluent: Yes\\
Has Unique Normal Forms: No

4. \quad A=\{a,b,c\}\quad and \quad {R}=\{(a,b),(a,c)\}

\begin{tikzcd}
	&& b \\
	a \\
	&& c
	\arrow[from=2-1, to=1-3]
	\arrow[from=2-1, to=3-3]
\end{tikzcd}\\
Terminating: Yes\\
Confluent: No\\
Has Unique Normal Forms: No

5. \quad A=\{a,b\}\quad and \quad {R}=\{(a,a),(a,b)\}

\begin{tikzcd}
	a && b
	\arrow[from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
	\arrow[from=1-1, to=1-3]
\end{tikzcd}\\
Terminating: No\\
Confluent: Yes\\
Has Unique Normal Forms: Yes

6. \quad A=\{a,b,c\}\quad and \quad {R}=\{(a,b),(b,b),(a,c)\}

\begin{tikzcd}
	&& b \\
	a \\
	&& c
	\arrow[from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow[from=2-1, to=1-3]
	\arrow[from=2-1, to=3-3]
\end{tikzcd}\\
Terminating: No\\
Confluent: No\\
Has Unique Normal Forms: No

7. \quad A=\{a,b,c\}\quad and \quad {R}=\{(a,b),(b,b),(a,c),(c,c)\}

\begin{tikzcd}
	&& b \\
	a \\
	&& c
	\arrow[from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow[from=2-1, to=1-3]
	\arrow[from=2-1, to=3-3]
	\arrow[from=3-3, to=3-3, loop, in=55, out=125, distance=10mm]
\end{tikzcd}\\
Terminating: No\\
Confluent: No\\
Has Unique Normal Forms: No

\begin{tabular}{|c|c|c|c|}
\hline
confluent & terminating & has unique normal forms & example \\
\hline
True  & True  & True  & 
\begin{tikzcd}
	a
\end{tikzcd}\\
True  & True  & False & IMPOSSIBLE \\
True  & False & True  & 
\begin{tikzcd}
	a && b
	\arrow[from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
	\arrow[from=1-1, to=1-3]
\end{tikzcd}\\
True  & False & False & 
\begin{tikzcd}
	a
	\arrow[from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
\end{tikzcd}\\
False & True  & True  & IMPOSSIBLE \\
False & True  & False &  
\begin{tikzcd}
	&& b \\
	a \\
	&& c
	\arrow[from=2-1, to=1-3]
	\arrow[from=2-1, to=3-3]
\end{tikzcd}\\
False & False & True  & IMPOSSIBLE \\
False & False & False & 
\begin{tikzcd}
	&& b \\
	a \\
	&& c
	\arrow[from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow[from=2-1, to=1-3]
	\arrow[from=2-1, to=3-3]
	\arrow[from=3-3, to=3-3, loop, in=55, out=125, distance=10mm]
\end{tikzcd}\\
\hline
\end{tabular}

\subsection{Week 3}

\subsubsection{Homework}

\textbf{Exercise 5}

ab → ba\\
ba → ab\\
aa →\\
b →\\

abba → aba → aa →\\
bababa → ababa → aaba → aaa → a

The ARS isn’t terminating because it has the loop ab → ba, ba → ab.

In the above example, abba → , bababa → a, which makes them non-equivalent. There are infinitely many non-equivalent strings, because all strings with an even number of a’s are only equivalent to each other, and all strings with an odd number of a’s are only equivalent to each other.

There are 2 equivalence classes, all strings with an odd number of a’s that have normal form a, and all strings with an even number of a’s that have normal form of an empty string.

By getting rid of the first 2 rules, the ARS is terminating, with the same equivalence classes. There is no longer a loop, and you can still get rid of the same letters.

How would you have to modify the ARS so that there is only one equivalence class?

\textbf{Exercise 5b}

ab → ba\\
ba → ab\\
aa → a\\
b →

abba → aba → aa → a\\
bababa → ababa → aaba → aaa → aa → a

The ARS isn’t terminating because it has the loop ab → ba, ba → ab.

bbb and aba are not equivalent. There are infinitely many non-equivalent strings, any string that has all b’s is not equivalent to any string that has at least one a in it.

There are 2 equivalence classes, all strings that have no a’s have the normal form of an empty string. All strings that have at least one a have the normal form a.

By getting rid of the first 2 rules, the ARS is terminating, with the same equivalence classes. There is no longer a loop, and you can still get rid of the same letters.

What would happen if aa → a was changed to aaa → a?

\subsection{Week 4}

\subsubsection{Homework}

\textbf{4.1}

\begin{verbatim}
while b != 0:
    temp = b
    b = a mod b
    a = temp
return a
\end{verbatim}

This algorithm always terminates under the condition that $a,b \in \mathbb {N}$.

We can define this ARS as: $A = {(a, b) |a,b \in \mathbb {N}}$, with transition, (a, b) → (b, a mod b).

A measure function is: $\phi(a,b) = b$.

Since a → b every iteration, if b is decreasing, so is a. In the transition, b → a mod b, a mod b will always be less than b, so, $\phi(a, b) > \phi$(b, a mod b). Since this algorithm has a measure function, it terminates.

\textbf{4.2}

\begin{verbatim}
function merge_sort(arr, left, right):
    if left >= right:
        return
    mid = (left + right) / 2
    merge_sort(arr, left, mid)
    merge_sort(arr, mid+1, right)
    merge(arr, left, mid, right)
\end{verbatim}

Prove that $\phi(left, right) = right - left + 1$ is a measure function.

For recursive calls, $left \le mid < right$.

For the left side recursive call:\\
merge sort(arr, left, mid) = mid - left + 1\\
right > mid, so, right - left + 1 > mid - left + 1\\
$\phi(left, right) > \phi(left, mid)$\\
This call terminates

For the right side recursive call:\\
merge sort(arr, mid + 1, right) = right - (mid + 1) + 1\\
$mid \ge left$, so, mid + 1 > left\\
right - left + 1 > right - (mid + 1) + 1 \\
$\phi(left, right) > \phi(mid + 1, right)$\\
This call terminates

Since both calls terminate, $\phi(left, right) = right - left + 1$ is a measure function for merge sort.

\subsection{Week 4}

\subsubsection{Homework}

($\lambda$f.$\lambda$x.f(f(x))) ($\lambda$f.$\lambda$x.(f(f(f x))))

alpha rule:\\
($\lambda$g.$\lambda$y.g(g(y))) ($\lambda$f.$\lambda$x.(f(f(f x))))

beta rule:\\
($\lambda$y.($\lambda$f.$\lambda$x.(f(f(f x)))) (($\lambda$f.$\lambda$x.(f(f(f x))))(y)))

beta rule:\\
($\lambda$y.($\lambda$f.$\lambda$x.(f(f(f x)))) ($\lambda$x.(y(y(y x)))))

alpha rule:\\
($\lambda$y.($\lambda$f.$\lambda$z.(f(f(f z)))) ($\lambda$x.(y(y(y x)))))

beta rule:\\
($\lambda$y.($\lambda$z.(($\lambda$x.(y(y(y x))))(($\lambda$x.(y(y(y x))))(($\lambda$x.(y(y(y x))))z)))))

beta rule:\\
($\lambda$y.($\lambda$z.(($\lambda$x.(y(y(y x))))(($\lambda$x.(y(y(y x))))(y(y(y z)))))))

beta rule:\\
($\lambda$y.($\lambda$z.(($\lambda$x.(y(y(y x))))(y(y(y (y(y(y z)))))))))

beta rule:\\
($\lambda$y.($\lambda$z.(y(y(y(y(y(y(y(y(y z)))))))))))

\subsection{Week 6}

\subsubsection{Homework}

let rec fact = $\lambda$n. if n=0 then 1 else n * fact (n-1) in fact 3

-> <def of let rec>\\
let fact = (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) in fact 3

-> <def of let>\\
($\lambda$fact. fact 3) (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))

-> <beta rule: substitute fix F>\\
(fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) 3

-> <def of fix>\\
(($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)) (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))) 3

-> <beta rule: substitute fix F>\\
($\lambda$n. if n=0 then 1 else n * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (n-1)) 3

-> <beta rule: substitute 3>\\
if 3=0 then 1 else 3 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (3-1)

-> <def of if>\\
3 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) 2

-> <def of fix>\\
3 * (($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)) (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))) 2

-> <beta rule>\\
3 * ($\lambda$n. if n=0 then 1 else n * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (n-1)) 2

-> <beta rule>\\
3 * (if 2=0 then 1 else 2 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (2-1))

-> <def of if>\\
3 * (2 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) 1)

-> <def of fix>\\
3 * (2 * (($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)) (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))) 1)

-> <beta rule>\\
3 * (2 * ($\lambda$n. if n=0 then 1 else n * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))(n-1)) 1)

-> <beta rule>\\
3 * (2 * (if 1=0 then 1 else 1 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))(1-1)))

-> <def of if>\\
3 * (2 * (1 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) 0))

-> <def of fix>\\
3 * (2 * (1 * (($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)) (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))) 0))

-> <beta rule>\\
3 * (2 * (1 * ($\lambda$n. if n=0 then 1 else n * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (n-1)) 0))

-> <beta rule>\\
3 * (2 * (1 * (if 0=0 then 1 else 0 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (0-1))))

-> <def of if>\\
3 * (2 * (1 * (1)))

-> <multiplication>\\
6

\subsection{Week 7}

\subsubsection{Homework}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{image.png}
\end{figure}

\subsection{Week 8}

\subsubsection{Homework}

\begin{verbatim}
Level 5: a + (b + 0) + (c + 0) = a + b + c
rw[add_zero]
rw[add_zero]
rfl

Level 6: a + (b + 0) + (c + 0) = a + b + c
rw[add_zero c]
rw[add_zero]
rfl

Level 7: For all natural numbers a, we have succ(a) = a + 1
rw[one_eq_succ_zero]
rw[add_succ]
rw[add_zero]
rfl

Level 8: 2 + 2 = 4
rw[four_eq_succ_three]
rw[three_eq_succ_two]
rw[two_eq_succ_one]
rw[one_eq_succ_zero]
rw[add_succ]
rw[add_succ]
rw[add_zero]
rfl

Natural Language Proof of Level 5:
a + (b + 0) + (c + 0) = a + b + c
a + b + c = a + b + c	              by algorithm 1: addition (m + 0 = 0)
True by reflexivity
\end{verbatim}

\section{Essay}

\section{Evidence of Participation}

\section{Conclusion}\label{conclusion}

\begin{thebibliography}{99}
\bibitem[BLA]{bla} Author, \href{https://en.wikipedia.org/wiki/LaTeX}{Title}, Publisher, Year.
\end{thebibliography}

\end{document}
