\documentclass{article}

\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{graphicx}
\usepackage{float}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{quiver}
\usepackage{array}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}
\usepackage[utf8]{inputenc}                                                    
\usepackage[T1]{fontenc}                                                       

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\newtheoremstyle{theorem}
  {\topsep}   % ABOVESPACE
  {\topsep}   % BELOWSPACE
  {\itshape\/}  % BODYFONT
  {0pt}       % INDENT (empty value is the same as 0pt)
  {\bfseries} % HEADFONT
  {.}         % HEADPUNCT
  {5pt plus 1pt minus 1pt} % HEADSPACE
  {}          % CUSTOM-HEAD-SPEC
\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{CPSC-354 Report}
\author{Annika Brown  \\ Chapman University}

\date{\today} 

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents

\section{Introduction}\label{intro}

\section{Week by Week}\label{homework}

\subsection{Week 1}

\subsubsection{MU Puzzle}

It is impossible to solve the MU puzzle. The only way to change the amount of I’s is to double them with rule 2, or subtract 3 with rule 3. In order to get rid of all the I’s you would have to have them in groups of 3. A power of x is divisible by 3 only if x is a multiple of 3, because the prime factorization of a number must include the prime number 3 for the number to be divisible by 3. So, you would have to get an original group divisible by 3, which is impossible.

\subsection{Week 2}

\subsubsection{Rewriting}

1. \quad A=\{\}\\
Empty ARS\\
Terminating: Yes\\
Confluent: Yes\\
Has Unique Normal Forms: Yes

2. \quad A=\{a\}\quad and \quad {R}=\{\}

\begin{tikzcd}
	a
\end{tikzcd}\\
Terminating: Yes\\
Confluent: Yes\\
Has Unique Normal Forms: Yes

3. \quad A=\{a\}\quad and \quad {R}=\{(a,a)\}

\begin{tikzcd}
	a
	\arrow[from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
\end{tikzcd}\\
Terminating: No\\
Confluent: Yes\\
Has Unique Normal Forms: No

4. \quad A=\{a,b,c\}\quad and \quad {R}=\{(a,b),(a,c)\}

\begin{tikzcd}
	&& b \\
	a \\
	&& c
	\arrow[from=2-1, to=1-3]
	\arrow[from=2-1, to=3-3]
\end{tikzcd}\\
Terminating: Yes\\
Confluent: No\\
Has Unique Normal Forms: No

5. \quad A=\{a,b\}\quad and \quad {R}=\{(a,a),(a,b)\}

\begin{tikzcd}
	a && b
	\arrow[from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
	\arrow[from=1-1, to=1-3]
\end{tikzcd}\\
Terminating: No\\
Confluent: Yes\\
Has Unique Normal Forms: Yes

6. \quad A=\{a,b,c\}\quad and \quad {R}=\{(a,b),(b,b),(a,c)\}

\begin{tikzcd}
	&& b \\
	a \\
	&& c
	\arrow[from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow[from=2-1, to=1-3]
	\arrow[from=2-1, to=3-3]
\end{tikzcd}\\
Terminating: No\\
Confluent: No\\
Has Unique Normal Forms: No

7. \quad A=\{a,b,c\}\quad and \quad {R}=\{(a,b),(b,b),(a,c),(c,c)\}

\begin{tikzcd}
	&& b \\
	a \\
	&& c
	\arrow[from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow[from=2-1, to=1-3]
	\arrow[from=2-1, to=3-3]
	\arrow[from=3-3, to=3-3, loop, in=55, out=125, distance=10mm]
\end{tikzcd}\\
Terminating: No\\
Confluent: No\\
Has Unique Normal Forms: No

\begin{tabular}{|c|c|c|c|}
\hline
confluent & terminating & has unique normal forms & example \\
\hline
True  & True  & True  & 
\begin{tikzcd}
	a
\end{tikzcd}\\
True  & True  & False & IMPOSSIBLE \\
True  & False & True  & 
\begin{tikzcd}
	a && b
	\arrow[from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
	\arrow[from=1-1, to=1-3]
\end{tikzcd}\\
True  & False & False & 
\begin{tikzcd}
	a
	\arrow[from=1-1, to=1-1, loop, in=55, out=125, distance=10mm]
\end{tikzcd}\\
False & True  & True  & IMPOSSIBLE \\
False & True  & False &  
\begin{tikzcd}
	&& b \\
	a \\
	&& c
	\arrow[from=2-1, to=1-3]
	\arrow[from=2-1, to=3-3]
\end{tikzcd}\\
False & False & True  & IMPOSSIBLE \\
False & False & False & 
\begin{tikzcd}
	&& b \\
	a \\
	&& c
	\arrow[from=1-3, to=1-3, loop, in=55, out=125, distance=10mm]
	\arrow[from=2-1, to=1-3]
	\arrow[from=2-1, to=3-3]
	\arrow[from=3-3, to=3-3, loop, in=55, out=125, distance=10mm]
\end{tikzcd}\\
\hline
\end{tabular}

\subsection{Week 3}

\subsubsection{Homework}

\textbf{Exercise 5}

ab → ba\\
ba → ab\\
aa →\\
b →\\

abba → aba → aa →\\
bababa → ababa → aaba → aaa → a

The ARS isn’t terminating because it has the loop ab → ba, ba → ab.

In the above example, abba → , bababa → a, which makes them non-equivalent. There are infinitely many non-equivalent strings, because all strings with an even number of a’s are only equivalent to each other, and all strings with an odd number of a’s are only equivalent to each other.

There are 2 equivalence classes, all strings with an odd number of a’s that have normal form a, and all strings with an even number of a’s that have normal form of an empty string.

By getting rid of the first 2 rules, the ARS is terminating, with the same equivalence classes. There is no longer a loop, and you can still get rid of the same letters.

How would you have to modify the ARS so that there is only one equivalence class?

\textbf{Exercise 5b}

ab → ba\\
ba → ab\\
aa → a\\
b →

abba → aba → aa → a\\
bababa → ababa → aaba → aaa → aa → a

The ARS isn’t terminating because it has the loop ab → ba, ba → ab.

bbb and aba are not equivalent. There are infinitely many non-equivalent strings, any string that has all b’s is not equivalent to any string that has at least one a in it.

There are 2 equivalence classes, all strings that have no a’s have the normal form of an empty string. All strings that have at least one a have the normal form a.

By getting rid of the first 2 rules, the ARS is terminating, with the same equivalence classes. There is no longer a loop, and you can still get rid of the same letters.

What would happen if aa → a was changed to aaa → a?

\subsection{Week 4}

\subsubsection{Homework}

\textbf{4.1}

\begin{verbatim}
while b != 0:
    temp = b
    b = a mod b
    a = temp
return a
\end{verbatim}

This algorithm always terminates under the condition that $a,b \in \mathbb {N}$.

We can define this ARS as: $A = {(a, b) |a,b \in \mathbb {N}}$, with transition, (a, b) → (b, a mod b).

A measure function is: $\phi(a,b) = b$.

Since a → b every iteration, if b is decreasing, so is a. In the transition, b → a mod b, a mod b will always be less than b, so, $\phi(a, b) > \phi$(b, a mod b). Since this algorithm has a measure function, it terminates.

\textbf{4.2}

\begin{verbatim}
function merge_sort(arr, left, right):
    if left >= right:
        return
    mid = (left + right) / 2
    merge_sort(arr, left, mid)
    merge_sort(arr, mid+1, right)
    merge(arr, left, mid, right)
\end{verbatim}

Prove that $\phi(left, right) = right - left + 1$ is a measure function.

For recursive calls, $left \le mid < right$.

For the left side recursive call:\\
merge sort(arr, left, mid) = mid - left + 1\\
right > mid, so, right - left + 1 > mid - left + 1\\
$\phi(left, right) > \phi(left, mid)$\\
This call terminates

For the right side recursive call:\\
merge sort(arr, mid + 1, right) = right - (mid + 1) + 1\\
$mid \ge left$, so, mid + 1 > left\\
right - left + 1 > right - (mid + 1) + 1 \\
$\phi(left, right) > \phi(mid + 1, right)$\\
This call terminates

Since both calls terminate, $\phi(left, right) = right - left + 1$ is a measure function for merge sort.

\subsection{Week 4}

\subsubsection{Homework}

($\lambda$f.$\lambda$x.f(f(x))) ($\lambda$f.$\lambda$x.(f(f(f x))))

alpha rule:\\
($\lambda$g.$\lambda$y.g(g(y))) ($\lambda$f.$\lambda$x.(f(f(f x))))

beta rule:\\
($\lambda$y.($\lambda$f.$\lambda$x.(f(f(f x)))) (($\lambda$f.$\lambda$x.(f(f(f x))))(y)))

beta rule:\\
($\lambda$y.($\lambda$f.$\lambda$x.(f(f(f x)))) ($\lambda$x.(y(y(y x)))))

alpha rule:\\
($\lambda$y.($\lambda$f.$\lambda$z.(f(f(f z)))) ($\lambda$x.(y(y(y x)))))

beta rule:\\
($\lambda$y.($\lambda$z.(($\lambda$x.(y(y(y x))))(($\lambda$x.(y(y(y x))))(($\lambda$x.(y(y(y x))))z)))))

beta rule:\\
($\lambda$y.($\lambda$z.(($\lambda$x.(y(y(y x))))(($\lambda$x.(y(y(y x))))(y(y(y z)))))))

beta rule:\\
($\lambda$y.($\lambda$z.(($\lambda$x.(y(y(y x))))(y(y(y (y(y(y z)))))))))

beta rule:\\
($\lambda$y.($\lambda$z.(y(y(y(y(y(y(y(y(y z)))))))))))

\subsection{Week 6}

\subsubsection{Homework}

let rec fact = $\lambda$n. if n=0 then 1 else n * fact (n-1) in fact 3

-> <def of let rec>\\
let fact = (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) in fact 3

-> <def of let>\\
($\lambda$fact. fact 3) (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))

-> <beta rule: substitute fix F>\\
(fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) 3

-> <def of fix>\\
(($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)) (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))) 3

-> <beta rule: substitute fix F>\\
($\lambda$n. if n=0 then 1 else n * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (n-1)) 3

-> <beta rule: substitute 3>\\
if 3=0 then 1 else 3 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (3-1)

-> <def of if>\\
3 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) 2

-> <def of fix>\\
3 * (($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)) (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))) 2

-> <beta rule>\\
3 * ($\lambda$n. if n=0 then 1 else n * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (n-1)) 2

-> <beta rule>\\
3 * (if 2=0 then 1 else 2 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (2-1))

-> <def of if>\\
3 * (2 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) 1)

-> <def of fix>\\
3 * (2 * (($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)) (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))) 1)

-> <beta rule>\\
3 * (2 * ($\lambda$n. if n=0 then 1 else n * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))(n-1)) 1)

-> <beta rule>\\
3 * (2 * (if 1=0 then 1 else 1 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))(1-1)))

-> <def of if>\\
3 * (2 * (1 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) 0))

-> <def of fix>\\
3 * (2 * (1 * (($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)) (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1)))) 0))

-> <beta rule>\\
3 * (2 * (1 * ($\lambda$n. if n=0 then 1 else n * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (n-1)) 0))

-> <beta rule>\\
3 * (2 * (1 * (if 0=0 then 1 else 0 * (fix ($\lambda$fact. $\lambda$n. if n=0 then 1 else n * fact (n-1))) (0-1))))

-> <def of if>\\
3 * (2 * (1 * (1)))

-> <multiplication>\\
6

\subsection{Week 7}

\subsubsection{Homework}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{image.png}
\end{figure}

\subsection{Week 8}

\subsubsection{Homework}

\begin{verbatim}
Level 5: a + (b + 0) + (c + 0) = a + b + c
rw[add_zero]
rw[add_zero]
rfl

Level 6: a + (b + 0) + (c + 0) = a + b + c
rw[add_zero c]
rw[add_zero]
rfl

Level 7: For all natural numbers a, we have succ(a) = a + 1
rw[one_eq_succ_zero]
rw[add_succ]
rw[add_zero]
rfl

Level 8: 2 + 2 = 4
rw[four_eq_succ_three]
rw[three_eq_succ_two]
rw[two_eq_succ_one]
rw[one_eq_succ_zero]
rw[add_succ]
rw[add_succ]
rw[add_zero]
rfl

Natural Language Proof of Level 5:
a + (b + 0) + (c + 0) = a + b + c
a + b + c = a + b + c	              by algorithm 1: addition (m + 0 = 0)
True by reflexivity
\end{verbatim}

\subsection{Week 9}

\subsubsection{Homework}

\begin{verbatim}
ADDITION WORLD LEVEL 5

WITH INDUCTION: a + b + c = a + c + b

induction b
rw[add_zero]
rw[add_zero]
rfl
rw[add_succ]
rw[succ_add]
rw[add_succ]
rw[n_ih]
rfl

a + b + c = a + c + b

Induction on b:
Basis: 		a + 0 + c = a + c + 0
			a + c = a + c + 0	      def of +
			a + c = a + c		      def of +
			True by reflexivity

Inductive Hypothesis: a + n + c = a + c + n

Inductive Step:	a + n↷ + c = a + c + n↷
			    (a + n)↷ + c = a + c + n↷	    def of +
			    (a + n + c)↷ =  a + c + n↷	    def of +
			    (a + n + c)↷ =  a + (c + n)↷	def of +
			    (a + n + c)↷ =  (a + c + n)↷	def of +
			    (a + c + n)↷ = (a + c + n)↷	inductive hypothesis
			    True by reflexivity
			
WITHOUT INDUCTION: a + b + c = a + c + b

rw[add_assoc]
rw[add_comm b]
rw[add_assoc]
rfl

(a + b) + c = (a + c) + b
a + (b + c) = (a + c) + b	associativity
a + (c + b) = (a + c) + b	commutativity
(a + c) + b = (a + c) + b	associativity
True by reflexivity
\end{verbatim}

\subsection{Week 10}

\subsubsection{Homework}

\begin{verbatim}
PARTY INVITES

LEVEL 6: example (C D S: Prop) (h : C ∧ D → S) : C → D → S := by
exact λ c d ↦ h ⟨c, d⟩

LEVEL 7: example (C D S: Prop) (h : C → D → S) : C ∧ D → S := by
exact λ c ↦ h c.left c.right

LEVEL 8: example (C D S : Prop) (h : (S → C) ∧ (S → D)) : S → C ∧ D := by
exact λ s ↦ ⟨h.left s, h.right s⟩

LEVEL 9: example (R S : Prop) : R → (S → R) ∧ (¬S → R) := by
exact λ r ↦ ⟨λ_ ↦ r, λ_ ↦ r⟩

Discord Question:
Why do we need to use a placeholder when there is no evidence?
\end{verbatim}

\subsection{Week 11}

\subsubsection{Homework}

\begin{verbatim}
FALSIFICATION

LEVEL 9: example (A P : Prop) (h : P → ¬A) : ¬(P ∧ A) := by
exact λ ⟨p, a⟩ => (h p) a

LEVEL 10: example (A P : Prop) (h: ¬(P ∧ A)) : P → ¬A := by
exact λ p a => h ⟨p, a⟩

LEVEL 11: example (A : Prop)(h : ¬¬¬A) : ¬A := by
exact λ a => h (λ na => na a)

LEVEL 12: example (B C : Prop) (h : ¬(B → C)) : ¬¬B := by
exact λ nb => h (λ b => False.elim (nb b)) 
\end{verbatim}

\subsection{Week 12}

\subsubsection{Homework}

\begin{verbatim}
hanoi 5 0 2  
	hanoi 4 0 1 
		hanoi 3 0 2
			hanoi 2 0 1 
				hanoi 1 0 2 = move 0 2 
				move  0 1
				hanoi 1 2 1 = move 2 1 
			move 0 2  
			hanoi 2 1 2  
				hanoi 1 1 0 = move 1 0  
				move  1 2  
				hanoi 1 0 2 = move 0 2 
        move 0 1
        hanoi 3 2 1
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
            move 2 1
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
    move 0 2
    hanoi 4 1 2
        hanoi 3 1 0
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
            move 1 0
            hanoi 2 2 0
                hanoi 1 2 1 = move 2 1
                move 2 0
                hanoi 1 1 0 = move 1 0
        move 1 2
        hanoi 3 0 2
            hanoi 2 0 1
                hanoi 1 0 2 = move 0 2
                move 0 1
                hanoi 1 2 1 = move 2 1
            move 0 2
            hanoi 2 1 2
                hanoi 1 1 0 = move 1 0
                move 1 2
                hanoi 1 0 2 = move 0 2
\end{verbatim}


\subsection{Week 13}

\subsubsection{Homework}

\begin{verbatim}
2. I added ((ab)c)
    It should reduce to a b c
    It reduced to (ab c)

   I added (\x. (\y. x)) y
   It became (\Var1.y), which is correct

   I added (\x. x x) (\x. x x)
   It resulted in: recursion error: maximum recursion depth exceeded

3. Avoiding capture substitution works by adding new variables like Var1 since in some cases there are two variables with the same name, like x, but they are actually different.
   I added (\x. (\y. x)) y, and it became (\Var1.y), so it avoided capture substitution.
   It is implemented by having it generate a new variable name if the expression starts with a lambda and has a different variable name for tree[1].

4. I don’t always get the expected result.
    I added ((ab)c), and it should reduce to a b c, but it reduced to (ab c), which is correct, but not what I expected.
    Not all computations reduce to normal form.
    I added (\x. x x) (\x. x x)
    It resulted in: recursion error: maximum recursion depth exceeded  

5. The smallest expression I can find that does not reduce to normal form is (\x. x x) (\x. x x)

7. 
((\m.\n. m n) (\f.\x. f (f x))) (\f.\x. f (f (f x))) 
((\Var1. (\f.\x. f (f x)) Var1) ) (\f.\x. f (f (f x)))
((\Var1. (\Var2.\x. Var2 (Var2 x)) Var1) ) (\f.\x. f (f (f x)))
((\Var2.\Var3. Var2 (Var2 Var3)) (\f.\x. f (f (f x))) )
((\Var2.\Var4. Var2 (Var2 Var4)) (\f.\x. f (f (f x))) )
(\Var5.((\f.(\x.(f (f (f x))))) ((\f.(\x.(f (f (f x))))) Var5)))

8. 
12: eval (((\m.(\n.(m n))) (\f.(\x.(f (f x))))) (\f.(\x.(f x)))) 
39: eval ((\m.(\n.(m n))) (\f.(\x.(f (f x)))))
	39: eval (\m.(\n.(m n)))
	44: sub ( (\n.(m n)), m, (\f.(\x.(f (f x)))) )
		82: sub ( (m Var1), m, (\f.(\x.(f (f x)))) )
			82: sub ( (m n), n, Var1 )
				85: sub ( m, n, Var1 )
				85: sub ( n, n, Var1 )
			85: sub ( m, m, (\f.(\x.(f (f x)))) )
			85: sub ( Var1, m, (\f.(\x.(f (f x)))) )
	45: eval (\Var1.((\f.(\x.(f (f x)))) Var1))
44: sub ( ((\f.(\x.(f (f x)))) Var1), Var1, (\f.(\x.(f x))) )
85: sub ( (\f.(\x.(f (f x)))),  Var1, (\f.(\x.(f x))) )
	82: sub ( (\Var3.(Var2 (Var2 Var3))), Var1, (\f.(\x.(f x))) )
	82: sub ( (\x.(f (f x))), f, Var2 )
		82: sub ( (f (f x)), x, Var4 )
			85: sub ( f, x, Var4 )
			85: sub ( (f x), x, Var4 )
				85: sub ( f, x, Var4 )
85: sub ( x, x, Var4 )
				82: sub ( (f (f Var4)), f, Var2 )
					85: sub ( f, f, Var2 )
					85: sub ( (f Var4), f, Var2 )
						85: sub ( f, f, Var2 )
						85: sub ( Var4, f, Var2 )
85: sub ( Var1,  Var1, (\f.(\x.(f x))) )
	45: eval ((\Var2.(\Var5.(Var2 (Var2 Var5)))) (\f.(\x.(f x))))
		39: eval (\Var2.(\Var5.(Var2 (Var2 Var5))))
		44: sub ( (\Var5.(Var2 (Var2 Var5))), Var2, (\f.(\x.(f x))) )
		45: eval (\Var6.((\f.(\x.(f x))) ((\f.(\x.(f x))) Var6)))

Discord Question: Are there any situations where the debugger can't or shouldn't be used?
\end{verbatim}

\section{Essay}

\section{Evidence of Participation}

\section{Conclusion}\label{conclusion}

\begin{thebibliography}{99}
\bibitem[BLA]{bla} Author, \href{https://en.wikipedia.org/wiki/LaTeX}{Title}, Publisher, Year.
\end{thebibliography}

\end{document}
